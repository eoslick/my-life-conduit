// src/main/java/com/ses/mylifeconduit/core/eventsourcing/StoredEvent.java
package com.ses.mylifeconduit.core.eventsourcing;

import com.ses.mylifeconduit.core.ddd.EntityId;
import com.ses.mylifeconduit.core.tenant.TenantId;
import com.ses.mylifeconduit.core.user.UserId; // Import UserId for metadata

import java.time.Instant;
import java.util.Arrays;
import java.util.Objects;
import java.util.UUID;

/**
 * Represents the raw, persisted form of a domain event as stored in the Event Store.
 * Includes the encrypted payload and associated metadata. This is primarily an
 * infrastructure concern, used when interacting directly with the persistence layer.
 *
 * @param eventId            Unique ID of the event persistence record (distinct from DomainEvent.eventId).
 * @param aggregateId        ID of the aggregate this event belongs to.
 * @param aggregateType      The class name or logical type name of the aggregate root.
 * @param tenantId           The tenant context.
 * @param sequenceNumber     The version of the aggregate *after* this event (used for optimistic locking and ordering).
 * @param eventType          The class name or logical type name of the domain event.
 * @param eventPayload       The raw, potentially encrypted payload of the domain event.
 * @param eventVersion       The schema version of the domain event (e.g., "V1").
 * @param metadataPayload    Additional metadata (e.g., user ID, correlation ID, encryption details) stored usually as TEXT/CLOB (e.g., JSON).
 *                           Alternatively, key metadata fields (like userId, encryption info) could be separate columns.
 *                           Let's store key metadata explicitly for now.
 * @param encryptionAlgorithmId Identifier for the algorithm used to encrypt eventPayload.
 * @param keyContextId       Identifier linking to the key context used for encryption.
 * @param occurredOn         Timestamp when the event was originally created/occurred.
 * @param storedOn           Timestamp when the event was persisted to the store.
 * @param userId             The ID of the user who caused this event (important for audit).
 */
public record StoredEvent(
        UUID eventId, // Persistence record ID
        EntityId aggregateId,
        String aggregateType,
        TenantId tenantId,
        long sequenceNumber, // Maps to aggregateVersion in DomainEvent
        String eventType,
        byte[] eventPayload, // Encrypted DomainEvent data
        String eventVersion, // DomainEvent schema version
        // Metadata fields:
        String encryptionAlgorithmId,
        UUID keyContextId,
        Instant occurredOn, // Original event timestamp
        Instant storedOn, // Persistence timestamp
        UserId userId      // User causing the event
        // String correlationId // Optional: For tracing requests across services/events
) {
    /**
     * Canonical constructor with validation and defensive copying.
     */
    public StoredEvent {
        Objects.requireNonNull(eventId, "eventId cannot be null");
        Objects.requireNonNull(aggregateId, "aggregateId cannot be null");
        Objects.requireNonNull(aggregateType, "aggregateType cannot be null");
        Objects.requireNonNull(tenantId, "tenantId cannot be null");
        if (sequenceNumber <= 0) throw new IllegalArgumentException("sequenceNumber must be positive");
        Objects.requireNonNull(eventType, "eventType cannot be null");
        Objects.requireNonNull(eventPayload, "eventPayload cannot be null");
        Objects.requireNonNull(eventVersion, "eventVersion cannot be null");
        Objects.requireNonNull(encryptionAlgorithmId, "encryptionAlgorithmId cannot be null");
        Objects.requireNonNull(keyContextId, "keyContextId cannot be null");
        Objects.requireNonNull(occurredOn, "occurredOn cannot be null");
        Objects.requireNonNull(storedOn, "storedOn cannot be null");
        Objects.requireNonNull(userId, "userId cannot be null");

        // Defensive copy
        eventPayload = Arrays.copyOf(eventPayload, eventPayload.length);
    }

    // Provide getter with defensive copy for the byte array
    public byte[] getEventPayload() {
        return Arrays.copyOf(eventPayload, eventPayload.length);
    }

    // Note: equals/hashCode/toString are generated by the record.
    // Consider overriding toString if payload should be masked.
    @Override
    public String toString() {
        return "StoredEvent{" +
                "eventId=" + eventId +
                ", aggregateId=" + aggregateId +
                ", aggregateType='" + aggregateType + '\'' +
                ", tenantId=" + tenantId +
                ", sequenceNumber=" + sequenceNumber +
                ", eventType='" + eventType + '\'' +
                ", eventPayload=[PROTECTED]" + // Mask payload
                ", eventVersion='" + eventVersion + '\'' +
                ", encryptionAlgorithmId='" + encryptionAlgorithmId + '\'' +
                ", keyContextId=" + keyContextId +
                ", occurredOn=" + occurredOn +
                ", storedOn=" + storedOn +
                ", userId=" + userId +
                '}';
    }
}